# 计算机的组成
- 运算器，进行运算，算术运算和逻辑运算
- 控制器，控制指令的执行
- 存储器，包括内存和外存，外存有硬盘，u盘等形式
- 输入设备，鼠标，键盘等
- 输出设备，比如显示器

运算器和控制器组成中央处理单元cpu，但是cpu的范围更大一下，还包括一些寄存器，总线等

## 运算器中比较重要的寄存器
- 算术逻辑单元ALU
  负责进行算术运算和逻辑运算
- 累加寄存器AC
  存储源操作数，比如一个数加另一个数，在累加计算器中存储一个加数，算术逻辑单元中也只能存储一个加数，运算完成得到的结果没有别的地方存储，会重新存在累加寄存器中，当做源操作数
- 数据缓冲寄存器DR
  暂时存储数据和指令
- 状态条件寄存器PSW
  存储条件码，比如溢出状态，除数为0等
- 不只有上述几个寄存器，只是上面几个比较重要
  
## 控制器中比较重要的寄存器
- 指令寄存器IR
  暂时存储要执行的指令
- 程序计数器PC
  很重要，存储指令执行的地址，要根据这个地址取出指令，然后执行
- 地址寄存器AR
  保存当前程序正在访问的地址
- 指令译码器ID
  分析指令操作码，将指令编译成可执行的内容
- 不只有上述几个寄存器，只是上面几个比较重要

## 指令和数据都存储在地址中，怎么判断取出的是指令还是数据呢？
- 根据指令的执行周期来判断取出的是指令还是数据
- 指令的执行周期是先取出指令，然后分析指令操作码，之后再执行指令，执行指令的时候才会去取数据
- 所以一开始取得是指令，在指令执行的时候取得是数据

## 一些寄存器的英文缩写
- PC程序计数器，控制器
- AR地址寄存器，控制器
- DR数据缓冲寄存器，运算器
- ID指令译码器，控制器
- PSW状态条件寄存器，运算器
- IR指令寄存器，控制器
- ALU算术逻辑单元，运算器
- AC累加寄存器，运算器


# 奇偶校验码

## 相关概念
### 码距
- 对于单个编码来说，要变成另一个编码只需要改变一位，所以码距为1，比如00改变一位就可以变成01或10
- 对于两个编码来说，A编码要变成B编码需要改变的位数，其实就是A编码和B编码有几位数不一样，比如00到11的码距就是2
- 对于校验来说，码距越大就越利于检错和纠错。因为码距越大，A编码就越不容易变成B编码

### 奇偶校验
- 奇偶校验就是在原本的编码最后面加一位校验码（注意只加一位），使得编码中1的个数为奇数（奇校验）或偶数（偶校验），这样码距就变成了2，也就是在传输一个编码时，这个编码最少变两个数，才会在接收的时候被当做正确数据接收。其实如果变得数多于两位，也必须是偶数个，才会被当做正确数据接收。

### 例子
![](http://cdn.frankjoey.com//img2/202210260954412.png)
可以看出至少变码距位数时，才会让接收方误把错误数据当正确数据接收


# 循环冗余校验码CRC

## 步骤

1. 首先会给一个原始的数据，和一个多项式
2. 多项式的最高次数是n，则在原始的信息数据后面加n个0，作为被除数
3. 根据多项式来写出除数，有多少次方，则第几加一位为1，比如多项式为G(x) = x^4+x^2+1,则相当于1*x^4+0*x^3+1*x^2+0*x^1+1*x^0,将左边1或0取出来就是10101，作为除数
4. 除的时候，每一位做异或运算，相同则为0，不同则为1，只取最后的余数，不要商
5. 最后的余数的位数，如果不足多项式最高次数n，则在左边补0，最后得到的数为校验码
6. 将校验码放到信息位后边发送出去，接收方接收到之后，也根据这个多项式得到的除数做除法，如果能除尽，则说明数据没有出错。

## 与奇偶校验码比较

- 校验的位数更多，奇偶校验码两位数变更就检不出来了，循环冗余校验码CRC可以校验多位
- 奇偶校验码和CRC都是只能检错，不能纠错

## 例子

1. 信息码101101 多项式G(x)= x^3 + x + 1
   ![](http://cdn.frankjoey.com//img2/202210261029920.png)
2. 信息码11101 多项式G(x)= x^6 + x^4 + x^3
   ![](http://cdn.frankjoey.com//img2/202210261034908.png)


# 海明码

## 步骤

1. 先确定在哪些位置插入校验码，校验码插入的位置是确定的，只不过个数不确定，会放在2^0,2^1,2^2……上，直到前面没有信息码不能再放校验码，组合成的数据，第一位必须是信息码
2. 然后确定校验码各个位上是0还是1.
   确认方法
   - 首先将信息码各位的位数使用2^n的形式相加
   - 然后判断信息码各位的加数之中是否包含校验码所在的位数，将包含的信息码位数找出来
   - 某位校验码的数字就由包含它位数的信息码的数字异或得来

## 例子

信息码1101
![](http://cdn.frankjoey.com//img2/202210261119660.png)

## 特点

与奇偶校验码和循环冗余校验码CRC不同的是，不但可以检错，还可以确定哪位信息码出错了，进行纠错
比如上面传过去之后错了一位
### 错的是信息码

![](http://cdn.frankjoey.com//img2/202210261130446.png)

### 错的是校验码

![](http://cdn.frankjoey.com//img2/202210261133514.png)